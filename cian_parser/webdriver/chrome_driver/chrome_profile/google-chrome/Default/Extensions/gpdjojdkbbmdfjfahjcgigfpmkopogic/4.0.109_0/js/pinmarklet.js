(function () {
  'use strict';

  // valid configuration parameters

  var config = [
  // send debugging messages to console.log
  "debug",
  // so extensions can send h, g, or r
  "pinMethod",
  // name of a function to call once we have data we want to render
  "render",
  // sent from third-party vendors like addthis, so we can tell it's them
  "via",
  // random user ID generated by pinit.js
  "guid",
  // name of the machine on pinterdev.com we want to test
  "pinbox",
  // don't pop an alert if there's trouble
  "quiet",
  // override $.a.quality if found
  "quality",
  // don't show the X in the header
  "noCancel",
  // don't show the header
  "noHeader",
  // force pinmarklet to run even though we're on pinterest.com
  "force",
  // switch document.URL to this value, for testing
  "here"];

  // hash list

  var hashList = [/08fb2eb6424d/, /1529ad2b2cc8/, /1847807c0ea1/, /1d1d5ffa1d50/, /20c46b653b00/, /25f7c9982cea/, /293aa4f9b3d0/, /32aa39d04eb4/, /415215dcadbf/, /540b2374abf1/, /6f145d4255cf/, /71c1f4783e6d/, /79f57d83d54a/, /820a6e7baa0f/, /85ae87da6618/, /871de03c9980/, /8c2d5961f7af/, /8de5d416e5d2/, /95fa195f8b6a/, /9e2089d8b8f2/, /a32353817e45/, /cefdc93047b7/, /dbafdf055617/, /eefa602a72ed/, /efa3a2deb839/];

  // do not pin if document.URL matches any of these:

  var nopeList = [/^https?:\/\/(.*?\.|)craigslist\.org\//, /^https?:\/\/(.*?\.|)chase\.com\//, /^https?:\/\/(.*?\.|)facebook\.com\//, /^https?:\/\/mail\.aol\.com\//, /^https?:\/\/(.*?\.|)atmail\.com\//, /^https?:\/\/(.*?\.|)contactoffice\.com\//, /^https?:\/\/(.*?\.|)fastmail\.fm\//, /^https?:\/\/(.*?\.|)webmail\.gandi\.net\//, /^https?:\/\/outlook\.live\.com\//, /^https?:\/\/(.*?\.|)mail\.live\.com\//, /^https?:\/\/post\.pinterest\.com\//, /^https?:\/\/mail\.ukr\.net\//, /^https?:\/\/plus\.google\.com\//, /^https?:\/\/outlook\.office\.com\//, /^https?:\/\/accounts\.google\.com\//, /^https?:\/\/myaccount\.google\.com\//, /^https?:\/\/mail\.google\.com\//, /^https?:\/\/inbox\.google\.com\//, /^https?:\/\/docs\.google\.com\//, /^https?:\/\/gmx\.com\//, /^https?:\/\/(.*?\.|)hushmail\.com\//, /^https?:\/\/(.*?\.|)laposte\.fr\//, /^https?:\/\/mail\.lycos\.com\//, /^https?:\/\/(.*?\.|)mail\.com\//, /^https?:\/\/(.*?\.|)mail\.ru\//, /^https?:\/\/(.*?\.|)opolis\.eu\//, /^https?:\/\/(.*?\.|)outlook\.com\//, /^https?:\/\/(.*?\.|)nokiamail\.com\//, /^https?:\/\/apps\.rackspace\.com\//, /^https?:\/\/mail\.rediff\.com\//, /^https?:\/\/(.*?\.|)runbox\.com\//, /^https?:\/\/mail\.sify\.com\//, /^https?:\/\/webmail\.thexyz\.com\//, /^https?:\/\/login\.yahoo\.com\//, /^https?:\/\/mail\.yahoo\.com\//, /^https?:\/\/mail\.yandex\.com\//];

  // iframe style rules

  var iframeStyle = {
    display: "block",
    position: "fixed",
    height: "100%",
    width: "100%",
    top: "0",
    left: "0",
    bottom: "0",
    right: "0",
    margin: "0",
    clip: "0",
    zIndex: "2147483647"
  };

  // strings for messaging

  var msg = {
    en: {
      noPinDomain: "Sorry, pinning is not allowed from this domain. Please contact the site operator if you have any questions.",
      noPinMeta: "Sorry, pinning is not allowed from this page. Please contact the site operator if you have any questions.",
      noPinnablesFound: "Sorry, couldn't find any pinnable things on this page."
    },
    cs: {
      noPinDomain: "Je nám líto. Z této domény není možné přidávat piny. S dotazy se obracejte na provozovatele webu.",
      noPinMeta: "Je nám líto. Z této stránky není možné přidávat piny. S dotazy se obracejte na provozovatele webu.",
      noPinnablesFound: "Je nám líto. Na této stránce jsme nenalezli žádný obsah, který by bylo možné připnout."
    },
    da: {
      noPinDomain: "Det er ikke muligt at tilføje pins fra domænet. Kontakt websitets ejer, hvis du har spørgsmål.",
      noPinMeta: "Det er ikke tilladt at sætte pins op fra denne side. Kontakt websitets ejer, hvis du har spørgsmål.",
      noPinnablesFound: "Der er ikke rigtigt noget at sætte op på denne side."
    },
    de: {
      noPinDomain: "Es tut uns leid, aber von dieser Domain kann nichts gepinnt werden. Bitte kontaktiere den Website-Betreiber, falls du weitere Fragen hast.",
      noPinMeta: "Es tut uns leid, aber von dieser Seite kann nichts gepinnt werden. Bitte kontaktiere den Website-Betreiber, falls du weitere Fragen hast.",
      noPinnablesFound: "Es tut uns leid, aber wir konnten auf dieser Seite nichts finden, was du pinnen könntest."
    },
    es: {
      noPinDomain: "Lo sentimos, no está permitido pinear desde este dominio. Ponte en contacto con el operador del sitio si tienes alguna pregunta.",
      noPinMeta: "Lo sentimos, no está permitido pinear desde esta página. Ponte en contacto con el operador del sitio si tienes alguna pregunta.",
      noPinnablesFound: "Lo sentimos, no hemos encontrado ningún elemento que se pueda pinear en esta página."
    },
    "es-mx": {
      noPinDomain: "Lamentablemente, no está permitido pinear desde este dominio. Si quieres hacer consultas, comunícate con el operador del sitio.",
      noPinMeta: "Lamentablemente, no está permitido pinear desde esta página. Si quieres hacer consultas, comunícate con el operador del sitio.",
      noPinnablesFound: "Lamentablemente, no se encontraron cosas para pinear en esta página."
    },
    el: {
      noPinDomain: "Λυπάμαι, δεν επιτρέπεται το καρφίτσωμα από αυτόν τον τομέα. Επικοινωνήστε με το διαχειριστή της ιστοσελίδας αν έχετε απορίες.",
      noPinMeta: "Λυπάμαι, δεν επιτρέπεται το καρφίτσωμα από αυτήν τη σελίδα. Επικοινωνήστε με το διαχειριστή της ιστοσελίδας αν έχετε απορίες.",
      noPinnablesFound: "Λυπάμαι, δεν ήταν δυνατή η εύρεση στοιχείων που μπορούν να καρφιτσωθούν σε αυτήν τη σελίδα."
    },
    fi: {
      noPinDomain: "Et voi tehdä Pin-lisäyksiä tästä verkkotunnuksesta. Jos sinulla on kysyttävää, ota yhteyttä sivuston ylläpitäjään.",
      noPinMeta: "Et voi tehdä Pin-lisäyksiä tältä sivulta. Jos sinulla on kysyttävää, ota yhteyttä sivuston ylläpitäjään.",
      noPinnablesFound: "Sivulta ei valitettavasti löydy sisältöä, jota voi lisätä."
    },
    fr: {
      noPinDomain: "Désolé, mais vous ne pouvez pas épingler les contenus de ce domaine. Pour toute question, veuillez contacter l'administrateur du site.",
      noPinMeta: "Désolé, mais vous ne pouvez pas épingler les contenus de cette page. Pour toute question, veuillez contacter l'administrateur du site.",
      noPinnablesFound: "Désolé, mais aucun contenu susceptible d'être épinglé n'a été trouvé sur cette page."
    },
    id: {
      noPinDomain: "Maaf, Anda tidak diizinkan mengepin dari domain ini. Hubungi operator situs jika Anda memiliki pertanyaan.",
      noPinMeta: "Maaf, Anda tidak diizinkan mengepin dari halaman ini. Silakan hubungi operator situs jika Anda memiliki pertanyaan.",
      noPinnablesFound: "Maaf, tidak ada yang bisa dipin dari halaman ini."
    },
    it: {
      noPinDomain: "Ci dispiace, ma l'aggiunta di Pin non è consentita da questo dominio. Se hai domande, contatta il gestore del sito.",
      noPinMeta: "Ci dispiace, ma l'aggiunta di Pin non è consentita da questa pagina. Se hai domande, contatta il gestore del sito.",
      noPinnablesFound: "Spiacenti, impossibile trovare immagini o video che è possibile aggiungere ai Pin in questa pagina."
    },
    hi: {
      noPinDomain: "क्षमा करें, इस डोमेन से पिन लगाने की अनुमति नहीं है। अगर आपका कोई प्रश्न हैं, तो कृपया साइट ऑपरेटर से संपर्क करें।",
      noPinMeta: "क्षमा करें, इस पेज से पिन लगाने की अनुमति नहीं है। अगर आपका कोई प्रश्न हैं, तो कृपया साइट ऑपरेटर से संपर्क करें।",
      noPinnablesFound: "क्षमा करें, इस पेज पर कोई भी पिन लगाने वाली चीज़ नहीं मिल सकी।"
    },
    hu: {
      noPinDomain: "Sajnáljuk, ebből a tartományból nem lehet pinelni. Kérjük, kérdéseiddel fordulj az oldal üzemeltetőjéhez.",
      noPinMeta: "Sajnáljuk, erről az oldalról nem lehet pinelni. Kérjük, kérdéseiddel fordulj az oldal üzemeltetőjéhez.",
      noPinnablesFound: "Sajnáljuk, ezen az oldalon nem található semmilyen pinelhető dolog."
    },
    ja: {
      noPinDomain: "し訳ありません。HTML 以外のページでピンすることはできません。画像をアップロードしようと試みている場合は、pinterest.com にアクセスしてください。",
      noPinMeta: "このページからのピンは許可されていません。ご質問がある場合は、サイト運営者にお問い合わせください。",
      noPinnablesFound: "申し訳ございません、このページでピンできるアイテムは見つかりませんでした。"
    },
    ko: {
      noPinDomain: "죄송합니다. 이 도메인에서는 핀하기가 허용되지 않습니다. 질문이 있으시면 사이트 운영자에게 문의하시기 바랍니다.",
      noPinMeta: "죄송합니다. 이 페이지에서는 핀하기가 허용되지 않습니다. 질문이 있으시면 사이트 운영자에게 문의하시기 바랍니다.",
      noPinnablesFound: "죄송합니다. 이 페이지에서 핀할 수 있는 것을 찾지 못했습니다."
    },
    ms: {
      noPinDomain: "Maaf, mengepin tidak dibenarkan dari domain ini. Sila hubungi pengendali laman jika anda ada sebarang solan.",
      noPinMeta: "Maaf, mengepin tidak dibenarkan dari halaman ini. Sila hubungi pengendali laman jika anda ada sebarang soalan.",
      noPinnablesFound: "Maaf, tidak dapat mencari sebarang imej yang boleh dipin pada halaman ini."
    },
    nb: {
      noPinDomain: "Beklager, pinning er ikke tillatt fra dette domenet. Ta kontakt med webmasteren hvis du har spørsmål.",
      noPinMeta: "Beklager, pinning er ikke tillatt fra denne siden. Ta kontakt med webmasteren hvis du har spørsmål.",
      noPinnablesFound: "Beklager, kunne ikke finne noen ting som kunne pinnes på denne siden."
    },
    nl: {
      noPinDomain: "Sorry, het is niet toegestaan om vanaf dit domein te pinnen. Neem contact op met de beheerder van deze website als je vragen hebt.",
      noPinMeta: "Sorry, het is niet toegestaan om vanaf dit domein te pinnen. Neem contact op met de beheerder van deze website als je vragen hebt.",
      noPinnablesFound: "Sorry, er is niets wat je kunt pinnen op deze pagina."
    },
    pl: {
      noPinDomain: "Niestety przypinanie z tej domeny jest niedozwolone. Skontaktuj się z operatorem witryny, jeśli masz pytania.",
      noPinMeta: "Niestety przypinanie z tej strony jest niedozwolone. Skontaktuj się z operatorem witryny, jeśli masz pytania.",
      noPinnablesFound: "Niestety na tej stronie nie ma żadnych rzeczy do przypinania."
    },
    pt: {
      noPinDomain: "Lamentamos, mas não é permitido afixar pins a partir deste domínio. Em caso de dúvidas, contacta o operador do site.",
      noPinMeta: "Lamentamos, mas não é permitido afixar pins a partir desta página. Em caso de dúvidas, contacta o operador do site.",
      noPinnablesFound: "Lamentamos, mas não foi possível encontrar nesta página nenhum conteúdo que possa ser afixado."
    },
    "pt-br": {
      noPinDomain: "Não é possível pinar a partir deste domínio. Entre em contato com o operador do site se tiver dúvidas.",
      noPinMeta: "Não é possível pinar a partir desta página. Entre em contato com o operador do site se tiver dúvidas.",
      noPinnablesFound: "Não foi possível encontrar nesta página conteúdo que possa ser pinado."
    },
    ro: {
      noPinDomain: "Ne pare rău, nu se pot adăuga Pinuri de pe acest site. Te rugăm să-l contactezi pe operatorul site-ului dacă ai întrebări.",
      noPinMeta: "Ne pare rău, nu se pot adăuga Pinuri de pe această pagină. Te rugăm să-l contactezi pe operatorul site-ului dacă ai întrebări.",
      noPinnablesFound: "Ne pare rău, nu am putut găsi conținut pentru adăugat ca Pinuri pe această pagină."
    },
    ru: {
      noPinDomain: "К сожалению, прикалывание Пинов в данном домене невозможно. Со всеми вопросами обращайтесь к администратору веб-сайта.",
      noPinMeta: "К сожалению, прикалывание Пинов с данной страницы невозможно. Со всеми вопросами обращайтесь к администратору веб-сайта.",
      noPinnablesFound: "На этой странице нет ничего, что можно было бы приколоть."
    },
    sk: {
      noPinDomain: "Prepáčte, z tejto domény si nemôžete pripínať piny. Kontaktujte prevádzkovateľa stránky, ak máte nejaké otázky.",
      noPinMeta: "Prepáčte, z tejto stránky si nemôžete pripínať piny. Kontaktujte prevádzkovateľa stránky, ak máte nejaké otázky.",
      noPinnablesFound: "Prepáčte, na tejto stránke sme nenašli nič na pripnutie."
    },
    sv: {
      noPinDomain: "Tyvärr går det inte att pinna från den här domänen. Kontakta webbplatsoperatören om du har frågor.",
      noPinMeta: "Det går inte att pinna från den här sidan. Kontakta webbplatsoperatören om du har frågor.",
      noPinnablesFound: "Det gick inte att hitta något på den här sidan som går att pinna."
    },
    th: {
      noPinDomain: "ขออภัย โดเมนนี้ไม่อนุญาตให้ปักพิน กรุณาติดต่อผู้ดูแลเว็บไซต์หากมีข้อสงสัย",
      noPinMeta: "ขออภัย เพจนี้ไม่อนุญาตให้ปักพิน กรุณาติดต่อผู้ดูแลเว็บไซต์หากมีข้อสงสัย",
      noPinnablesFound: "ขออภัย ไม่พบอะไรที่ปักพินได้ในเพจนี้"
    },
    tl: {
      noPinDomain: "Sorry, hindi allowed ang pinning sa domain na 'to. Paki-contact ang site operator kung may tanong ka.",
      noPinMeta: "Sorry, hindi allowed ang pinning mula sa page na 'to. Paki-contact ang site operator kung may tanong ka.",
      noPinnablesFound: "Sorry, walang makitang puwedeng i-pin sa page na 'to."
    },
    tr: {
      noPinDomain: "Üzgünüz, bu alan adından pinlemeye izin verilmiyor. Sorularınız varsa, lütfen site operatörüne başvurun.",
      noPinMeta: "Üzgünüz, bu sayfadan pinlemeye izin verilmiyor. Sorularınız varsa, lütfen site operatörüne başvurun.",
      noPinnablesFound: "Üzgünüz, bu sayfada pinlenebilecek bir şey bulunamadı."
    },
    uk: {
      noPinDomain: "На жаль, приколювати піни з цього домену не можна. Якщо у вас виникли запитання, зв'яжіться з оператором веб-сайту.",
      noPinMeta: "На жаль, приколювати піни з цієї сторінки не можна. Якщо у вас виникли запитання, зв'яжіться з оператором веб-сайту.",
      noPinnablesFound: "На жаль, ми не змогли знайти на цій сторінці зображень, які можна було б приколоти."
    },
    vi: {
      noPinDomain: "Rất tiếc, không cho phép ghim từ miền này. Vui lòng liên hệ người điều hành trang web nếu bạn có thắc mắc.",
      noPinMeta: "Rất tiếc, không cho phép ghim từ trang này. Vui lòng liên hệ người điều hành trang web nếu bạn có thắc mắc.",
      noPinnablesFound: "Rất tiếc, không thể tìm thấy thứ gì ghim được trên trang này."
    },
    // simplified Chinese  - show for anything starting with zh that is not zh-tw
    zh: {
      noPinDomain: "抱歉，不允许从此域收藏 Pin 图。如有疑虑请联系网站运营商。",
      noPinMeta: "抱歉，不允许从此域收藏 Pin 图。如有疑虑请联系网站运营商。",
      noPinnablesFound: "抱歉，未在此页面中找到可收藏的 Pin 图。"
    },
    // traditional Chinese
    "zh-tw": {
      noPinDomain: "抱歉！不允許從此網域收藏釘圖。若有疑問，請聯絡網站營運商。",
      noPinMeta: "抱歉！不允許從此網頁收藏釘圖。若有疑問，請聯絡網站營運商。",
      noPinnablesFound: "抱歉！在此網頁上找不到任何可收藏釘圖的內容。"
    }
  };

  // regexes for matching various things

  var pattern = {
    att: {
      amazonAsin: "data-fling-asin"
    },
    iframe: {
      youtube: /^(https?:|)\/\/www\.youtube\.com\/embed\//,
      instagram: /^https?:\/\/www\.instagram\.com\/p\//,
      vimeo: /^(https?:|)\/\/player\.vimeo\.com\/video\//
    },
    img: {
      twitter: /^https?:\/\/pbs\.twimg\.com\/media\//,
      youtube: /^(https?:|)\/\/i.ytimg.com\/vi\//
    },
    link: {
      youtubeWatch: /^(https?:|)\/\/(www|m)\.youtube\.com\/watch?/
    },
    page: {
      instagramPage: /^https?:\/\/www\.instagram\.com\//,
      instagramPhoto: /^https?:\/\/www\.instagram\.com\/p\//,
      twitter: /^https?:\/\/twitter\.com\//,
      amazonPage: /^https?:\/\/www\.amazon\.com\//,
      amazonProduct: /^https?:\/\/www\.amazon\.com((\/|.*)\/dp\/)/,
      youtubeWatch: /^https?:\/\/(www|m)\.youtube\.com\/watch?/,
      youtubeMobile: /^https?:\/\/m\.youtube\.com\//,
      googleImageSearch: /^https?:\/\/www\.google\.com\/search(.*tbm=isch.*)/
    }
  };

  // export global arguments

  var a = {
    // current version for logging
    ver: "2020021201",
    // where to find the unauthed grid
    grid: "https://assets.pinterest.com/ext/grid.html?" + new Date().getTime(),
    // what to match against when looking for my own script
    me: /\/\/assets\.pinterest\.com\/js\/pinmarklet\.js/,
    // whoat to log under
    logType: "pinmarklet",
    // where to log
    log: "https://log.pinterest.com/",
    // how long to wait before rendering what we have
    maxWait: 5000,
    // width of a thumbnail for comparison when determining whether to show an imageless thumb
    thumbSize: 237,
    // max score divided by quality number determines the cutoff
    quality: 30,
    // set this on document.body so we don't try to render the unauthed grid twice
    hazPinningNow: "data-pinterest-pinmarklet-rendered",
    config: config,
    hashList: hashList,
    nopeList: nopeList,
    iframeStyle: iframeStyle,
    msg: msg,
    pattern: pattern
  };

  // explort global variable space, some with defaults set

  var v = {
    override: {},
    config: {
      debug: false,
      pinMethod: "bookmarklet",
      domain: "www",
      lang: "en"
    },
    data: {
      img: {},
      link: {},
      meta: {},
      script: []
    },
    count: {
      imgLoading: 0,
      apiCalls: 0
    },
    time: {
      start: new Date().getTime()
    }
  };

  // important: leave $.f alone; we're going to add callback functions
  var f = {
    // an empty array for callback functions
    callback: []
  };

  // a master key so JSON-P callbacks can find their way home
  var myKey = "PIN_" + new Date().getTime();

  // connect everything together so it can all access the $ chain
  var $ = window[myKey] = {
    d: document,
    w: window,
    v: v,
    a: a,
    f: f
  };

  // master key should be treated as an argument
  $.a.k = myKey;

  // send notes to the console

  function debug(o) {
    // console.log only if debug is on
    if ($.v.config.debug && $.w.console) {
      if ($.w.console.log) {
        console.log(o);
      } else {
        // some sites (Twitter) that disable console.log don't know about console.table
        if ($.w.console.table) {
          $.w.console.table(o);
        }
      }
    }
  }

  // return the SHA-1 checksum of a string

  function sha(o) {
    var h = {
      rstr2binb: function rstr2binb(input) {
        var i = void 0,
            output = Array(input.length >> 2);
        for (i = 0; i < output.length; i++) {
          output[i] = 0;
        }
        for (i = 0; i < input.length * 8; i += 8) {
          output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << 24 - i % 32;
        }
        return output;
      },
      binb2rstr: function binb2rstr(input) {
        var i = void 0,
            output = "";
        for (i = 0; i < input.length * 32; i += 8) {
          output += String.fromCharCode(input[i >> 5] >>> 24 - i % 32 & 0xff);
        }
        return output;
      },
      safe_add: function safe_add(x, y) {
        var lsw = void 0,
            msw = void 0;
        lsw = (x & 0xffff) + (y & 0xffff);
        msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return msw << 16 | lsw & 0xffff;
      },
      bit_rol: function bit_rol(num, cnt) {
        return num << cnt | num >>> 32 - cnt;
      },
      binb_sha1: function binb_sha1(x, len) {
        var a = void 0,
            b = void 0,
            c = void 0,
            d = void 0,
            e = void 0,
            w = void 0,
            i = void 0,
            j = void 0,
            t = void 0,
            oa = void 0,
            ob = void 0,
            oc = void 0,
            od = void 0,
            oe = void 0;
        x[len >> 5] |= 0x80 << 24 - len % 32;
        x[(len + 64 >> 9 << 4) + 15] = len;
        w = Array(80);
        a = 1732584193;
        b = -271733879;
        c = -1732584194;
        d = 271733878;
        e = -1009589776;
        for (i = 0; i < x.length; i += 16) {
          oa = a;
          ob = b;
          oc = c;
          od = d;
          oe = e;
          for (j = 0; j < 80; j++) {
            if (j < 16) {
              w[j] = x[i + j];
            } else {
              w[j] = h.bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
            }
            t = h.safe_add(h.safe_add(h.bit_rol(a, 5), h.sha1_ft(j, b, c, d)), h.safe_add(h.safe_add(e, w[j]), h.sha1_kt(j)));
            e = d;
            d = c;
            c = h.bit_rol(b, 30);
            b = a;
            a = t;
          }
          a = h.safe_add(a, oa);
          b = h.safe_add(b, ob);
          c = h.safe_add(c, oc);
          d = h.safe_add(d, od);
          e = h.safe_add(e, oe);
        }
        return Array(a, b, c, d, e);
      },
      sha1_ft: function sha1_ft(t, b, c, d) {
        if (t < 20) return b & c | ~b & d;
        if (t < 40) return b ^ c ^ d;
        if (t < 60) return b & c | b & d | c & d;
        return b ^ c ^ d;
      },
      sha1_kt: function sha1_kt(t) {
        return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;
      },
      rstr_sha1: function rstr_sha1(s) {
        return h.binb2rstr(h.binb_sha1(h.rstr2binb(s), s.length * 8));
      },
      rstr2hex: function rstr2hex(input) {
        var hex_tab = void 0,
            output = void 0,
            x = void 0,
            i = void 0;
        hex_tab = "0123456789abcdef";
        output = "";
        for (i = 0; i < input.length; i++) {
          x = input.charCodeAt(i);
          output = output + hex_tab.charAt(x >>> 4 & 0x0f) + hex_tab.charAt(x & 0x0f);
        }
        return output;
      }
    };
    // set up a space to hold these if it doesn't already exist
    if (!$.v.sha) {
      debug("setting up hash repo");
      $.v.sha = {};
    }
    // compute and cache results if not found
    if (!$.v.sha[o.str]) {
      $.v.sha[o.str] = h.rstr2hex(h.rstr_sha1(o.str));
    }
    // return
    return $.v.sha[o.str];
  }

  // send logging pings
  // TODO before using this function in extension logic: make it non-pinmarklet-specific

  function log(o) {
    var k = void 0,
        q = void 0;
    o.url = o.url || $.v.here;
    q = "?type=" + $.a.logType + "&v=" + $.a.ver;
    if (o.reason === "grid_rendered") {
      // generated by a third party kind enough to tell us who they are
      if ($.v.config.via) {
        o.via = $.v.config.via;
      }
      // generated by pinit.js
      if ($.v.config.guid) {
        o.guid = $.v.config.guid;
      }
    }
    for (k in o) {
      if (k !== "extras") {
        q = q + "&pm" + k.charAt(0).toUpperCase() + k.slice(1) + "=" + encodeURIComponent(o[k]);
      }
    }
    // append any extra keys and values we may have sent that should NOT start with pM
    if (o.extras) {
      for (k in o.extras) {
        if (o.extras[k] && o.extras[k].hasOwnProperty) {
          q = q + "&" + k + "=" + o.extras[k];
        }
      }
    }
    new Image().src = $.a.log + q;
    debug("Logging: " + q);
  }

  // hash a domain and check it against the disallowed list

  function checkDisallowedDomain(o) {
    var h = void 0,
        i = void 0,
        j = void 0,
        p = void 0,
        r = void 0,
        t = void 0;
    // what we're returning
    r = false;

    for (i = 0; i < $.a.nopeList.length; i = i + 1) {
      if (o.url.match($.a.nopeList[i])) {
        log({ reason: "nope_list" });
        return true;
      }
    }

    // get the domain part
    p = o.url.split("/");
    if (p[2]) {
      // split into subcomponents
      p = p[2].split(".");
      // test all possible domains you can make from these components
      if (p.length > 1) {
        // start with the top-level domain, .com
        t = p.pop();
        // test foo.com, then www.foo.com
        for (i = p.length - 1; i > -1; i = i - 1) {
          t = p[i] + "." + t;
          // get the hash
          h = sha({ str: t });
          // do any of our partial hashes match our domain?
          for (j = $.a.hashList.length - 1; j > -1; j = j - 1) {
            if (h.match($.a.hashList[j])) {
              // return the domain that failed instead of true,
              // so we can pop special alerts for special domains
              return t;
            }
          }
        }
      }
    }
    return r;
  }

  // exit as gracefully as possible

  function done() {
    if ($.v.data.close) {
      // if we've rendered the grid from the extension, close it
      if (typeof $.f.extendedClose === "function") {
        $.f.extendedClose();
      } else {
        // have we been instructed not to say anything?
        if (!$.v.config.quiet) {
          $.w.setTimeout(function () {
            $.w.alert($.v.data.close);
          }, 10);
        }
      }
    }
  }

  // get an attribute from a DOM element

  function get(o) {
    var v = null;
    if (o.el && o.att) {
      if (typeof o.el[o.att] !== "undefined") {
        v = o.el[o.att];
      } else {
        v = o.el.getAttribute(o.att);
      }
    }
    return v;
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  // return the best guess for the description that should be offered for any image

  function getDescription(o) {
    var r = void 0,
        filter = void 0;
    // if we don't have an object we're going to look at the page
    o = o || {};

    // don't allow single-word descriptions that appear to be files or URLs
    filter = function filter(str) {
      // we might get undefined
      if (str) {
        // we might get an array if we are looking at a META
        if ((typeof str === "undefined" ? "undefined" : _typeof(str)) === "object" && str.length) {
          str = str[0];
        }
        // trim leading and trailing spaces
        str = str.trim();
        // are there zero spaces in the remaining string?
        if (!str.match(/\s/)) {
          // trim hash and query hash
          str = str.split("#")[0].split("?")[0];
          // does it start with an http protocol or end with a file format we know about?
          if (str.match(/^http?s:\/\//) || str.match(/\.(gif|jpeg|jpeg|png|webp)/)) {
            // clear it out
            str = "";
          }
        }
      } else {
        str = "";
      }
      return str;
    };

    // has the reader selected any text?
    r = filter("" + $.w.getSelection());
    if (!r) {
      // should we look at the image
      if (o.src) {
        // does the image have a data-pin-description?
        r = filter(get({ el: o, att: "data-pin-description" }));
        // does the image have a title?
        // NOTE we are ignoring alt attributes as of 2019-02-28
        if (!r) {
          r = filter(o.title);
        }
        // does the page have document.title?
        if (!r) {
          r = filter($.d.title);
        }
      } else {
        // does the page have a generic meta description or title?
        if (!r) {
          r = filter($.v.data.meta.description || $.v.data.meta.title);
        }
        // does the page have an OG description?
        if (!r) {
          r = filter($.v.ogDescription);
        }
        // does the page have document.title?
        if (!r) {
          r = filter($.d.title);
          // allow filenames for imageless pins
          if (!r && o.imageless) {
            // split the URL, take last element of path, remove hash, remove query, remove file extension
            r = $.v.here.split("/").pop().split("#")[0].split("?")[0].split(".")[0];
          }
        }
      }
    }
    return r;
  }

  // filter un-pinnable images

  function filterImg(o) {
    // is either dimension under 90
    if (o.width < 90 || o.height < 90) {
      return "Image dimensions are both too small.";
    }
    // both dimensions under 120
    if (o.width < 120 && o.height < 120) {
      return "One image dimension is too small.";
    }
    // width is greater than 3x height
    if (o.width > o.height * 3) {
      return "Image is too wide.";
    }
    // data URIs are not currently allowed in the grid or to be sent to unauthed pin create form
    if (!o.src.match(/^https?:\/\//)) {
      return "Image source does not begin with http.";
    }
    return false;
  }

  // call me when an image that we've re-rendered has loaded

  function getImgData(o) {
    return {
      status: "loaded",
      height: o.naturalHeight || 0,
      width: o.naturalWidth || 0,
      src: o.src
    };
  }

  // reload an image, so we know a) it exists and b) its true height and width

  function loadImg(o) {
    var img = void 0,
        test = void 0,
        hash = void 0;
    if (o.src) {
      if (!checkDisallowedDomain({ url: o.src })) {
        hash = sha({ str: o.src });
        // don't try to load if we've already got this one
        if (!$.v.data.img[hash]) {
          // see if we can find the image extension and bail out if it's SVG
          test = o.src.split("#")[0].split("?")[0].split(".").pop();
          if (test === "svg") {
            $.v.data.img[hash] = {
              src: o.src,
              status: "invalid",
              reason: "SVG images are not supported on Pinterest"
            };
            return;
          }
          // start a new image
          img = new Image();
          // increment image-loading count
          $.v.count.imgLoading = $.v.count.imgLoading + 1;
          $.v.data.img[hash] = {
            mod: o.mod || {},
            status: "loading"
          };
          // did not load property
          img.onerror = function (e) {
            var checkMe = void 0;
            // decrement image-loading count
            $.v.count.imgLoading = $.v.count.imgLoading - 1;
            // do we need to remove data-pin-media from some other image's mod object?
            for (checkMe in $.v.data.img) {
              if ($.v.data.img[checkMe].mod && $.v.data.img[checkMe].mod.pinMedia === o.src) {
                delete $.v.data.img[checkMe].mod.pinMedia;
              }
            }
            $.v.data.img[hash].status = "error";
          };
          // loaded
          img.onload = function () {
            // get image attributes
            var k = void 0,
                upHash = void 0,
                data = getImgData(img),
                filterReason = filterImg(data);

            if (o.override) {
              for (k = 0; k < o.override.length; k = k + 1) {
                $.v.override[o.override[k]] = true;
              }
            }

            if (!filterReason) {
              // prevent imageless pin representations if we have at least one image larger than 237x237
              if (data.height > $.a.thumbSize && data.width > $.a.thumbSize) {
                $.v.override.imageless = true;
              }
              if (o.mod) {
                $.v.data.img[hash].mod = o.mod;
              }
              for (k in data) {
                // set all properties
                if (data[k]) {
                  $.v.data.img[hash][k] = data[k];
                }
              }
              if (o.src === $.v.here) {
                // don't fill in a default description
                k.description = "";
                // don't produce an imageless pin
                $.v.override.imageless = true;
              }
              // we need to swap out an image found on the page for an image that's been loaded live
              if (o.update) {
                debug("Image source changed from " + o.update + " to " + o.src);
                upHash = sha({ str: o.update });
                $.v.data.img[upHash] = $.v.data.img[hash];
                if (o.mod) {
                  $.v.data.img[upHash].mod = o.mod;
                }
                $.v.data.img[upHash].src = o.src;
                $.v.data.img[upHash].height = data.height;
                $.v.data.img[upHash].width = data.width;
                $.v.data.img[hash] = $.v.data.img[upHash];
                $.v.data.img[hash].status = "ok";
                delete $.v.data.img[upHash];
              } else {
                $.v.data.img[hash].status = "ok";
              }
            } else {
              // update so we know it was filtered and why
              $.v.data.img[hash] = {
                status: "filtered",
                reason: filterReason,
                src: o.src.substr(0, 64)
              };
              // add an ellipsis if we've truncated the source
              if (o.src.length > 64) {
                $.v.data.img[hash].src = $.v.data.img[hash].src + "...";
              }
            }
            // decrement image-loading count
            $.v.count.imgLoading = $.v.count.imgLoading - 1;
          };
          // setting the source is enough to start modern browsers loading the image
          img.src = o.src;
        }
      }
    }
  }

  // call a JSON-P endpoint

  function call(o) {
    var n = void 0,
        s = void 0,
        id = void 0,
        sep = "?";
    // we're inside an extension or other client that can't handle JSON-P returns
    if (!$.v.doNotCall) {
      $.v.count.apiCalls = $.v.count.apiCalls + 1;
      // next available callback
      n = $.f.callback.length;
      // id will help us remove the SCRIPT tag later
      id = $.a.k + ".f.callback[" + n + "]";
      // create the callback
      $.f.callback[n] = function (r) {
        $.v.count.apiCalls = $.v.count.apiCalls - 1;
        o.func(r, n);
        var s = $.d.getElementById(id);
        s.parentNode.removeChild(s);
      };
      // some calls may come with a query string already set
      if (o.url.match(/\?/)) {
        sep = "&";
      }
      // make and call the new script node
      s = $.d.createElement("SCRIPT");
      s.id = id;
      s.type = "text/javascript";
      s.charset = "utf-8";
      s.src = o.url + sep + "callback=" + id;
      $.d.body.appendChild(s);
      debug("Calling: " + s.src);
    }
  }

  // handle iframe exceptions

  function handleIframe() {
    var m = void 0,
        i = void 0,
        c = void 0,
        p = void 0,
        q = void 0;
    m = $.d.getElementsByTagName("IFRAME");
    for (i = 0; i < m.length; i = i + 1) {
      // skip any iframes with nopin or data-pin-nopin
      if (m[i].getAttribute("nopin") || m[i].getAttribute("data-pin-nopin")) {
        continue;
      }

      // nothing happens if we don't have content
      c = m[i].getAttribute("src");
      if (c && c.match(/^(https?:|)\/\//)) {
        c = c.split("#")[0].split("?")[0];

        // youtube
        if (c.match($.a.pattern.iframe.youtube)) {
          p = c.split("/");
          if (p[4]) {
            debug("found a YouTube player: " + m[i].src);
            loadImg({
              src: "https://img.youtube.com/vi/" + p[4] + "/hqdefault.jpg",
              mod: {
                multimedia: true,
                url: "https://www.youtube.com/watch?v=" + p[4],
                description: getDescription()
              }
            });
          }
          continue;
        }

        // instagram
        if (c.match($.a.pattern.iframe.instagram)) {
          p = c.split("/");
          if (p[4]) {
            debug("found an Instagram embed: " + m[i].src);
            loadImg({
              src: "https://instagram.com/p/" + p[4] + "/media/?size=l",
              mod: {
                url: "https://www.instagram.com/p/" + p[4] + "/",
                description: getDescription()
              }
            });
          }
          continue;
        }

        // vimeo
        if (c.match($.a.pattern.iframe.vimeo)) {
          p = "https://vimeo.com/api/oembed.json?url=" + encodeURIComponent(m[i].src);
          q = function q(r) {
            if (r.thumbnail_url) {
              loadImg({
                src: r.thumbnail_url.split("_")[0] + ".jpg",
                mod: {
                  multimedia: true,
                  url: "https://vimeo.com/" + r.video_id,
                  description: r.title
                }
              });
            }
          };
          call({ url: p, func: q });
          continue;
        }
      }
    }
    debug($.v.data.iframe);
  }

  // find some or all of the images on the page and decide if they are pinnable

  function handleImg() {
    var i = void 0,
        m = void 0,
        mod = void 0,
        order = 0,
        pinMeOnly = void 0;

    // we may have found a pinnable image; check to see if it's
    // good and/or deserves special treatment
    var processImage = function processImage(img) {
      var v = void 0,
          a = void 0,
          q = void 0;
      // be sure we have a source
      if (img.currentSrc) {
        // save things we want to retain
        mod = {
          description: getDescription(img),
          sourceOrder: order
        };
        order = order + 1;
        // skip images with inline nopin attributes
        v = img.getAttribute("nopin") || img.getAttribute("data-pin-nopin");
        if (v) {
          return;
        }
        // don't alter links to point to deep-linked images
        a = img.parentNode;
        if (a.tagName === "A" && a.href) {
          // does this domain match the hosting page's domain?
          if ($.v.here.split("/")[2] === a.href.split("/")[2]) {
            // are we looking at an image that's deep-linked to another image?
            // does the URL run JavaScript when clicked per BUG-95302?
            if (!a.href.match(/(^javascript|\.gif|\.jpg|\.jpeg|\.png|\.webp)/)) {
              mod.url = a.href;
            }
          }
        }
        // does the site only want us to pin this one thing?
        v = img.getAttribute("data-pin-me-only");
        if (v) {
          mod.pinMeOnly = true;
        }
        // pin ID
        v = img.getAttribute("data-pin-id");
        if (v) {
          mod.pinId = v;
        }
        // suggested default description
        v = img.getAttribute("data-pin-description");
        if (v) {
          mod.pinDescription = v;
        }
        // URL to pin instead of document.URL
        v = img.getAttribute("data-pin-url");
        if (v) {
          mod.pinUrl = v;
        }
        // media to pin instead of this image
        v = img.getAttribute("data-pin-media");
        // do we have data-pin-media?
        if (v) {
          // we have media -- always give the mod boost to increase sort order of data-pin-media
          mod.pinMedia = v;
          // will we need to reload and update?
          if (v === img.currentSrc) {
            // if data-pin-media is the same as the current source, load it without the update flag
            loadImg({ src: img.currentSrc, mod: mod });
          } else {
            // data-pin-media is different so we need to update
            loadImg({ src: v, mod: mod, update: img.currentSrc });
          }
        } else {
          // we do not have media, so load whatever is currently on the screen
          loadImg({ src: img.currentSrc, mod: mod });
        }
        // be nice to Twitter
        if ($.v.here.match($.a.pattern.page.twitter) && img.currentSrc.match($.a.pattern.img.twitter)) {
          a = img.parentNode;
          while (a.tagName) {
            q = a.getAttribute("data-permalink-path");
            if (q) {
              mod.url = "https://twitter.com" + q;
              mod.description = a.parentNode.getElementsByTagName("P")[0].textContent;
              a = $.d.body;
            }
            a = a.parentNode;
          }
        }
        // be nice to YouTube thumbs
        if (img.currentSrc.match($.a.pattern.img.youtube)) {
          a = img.currentSrc.split("/vi/");
          if (a.length) {
            q = a[1].split("/")[0];
            if (q) {
              loadImg({
                mod: {
                  multimedia: true,
                  url: "https://www.youtube.com/watch?v=" + q
                },
                src: "https://i.ytimg.com/vi/" + q + "/hqdefault.jpg",
                update: img.currentSrc
              });
            }
          }
        }
      }
    };

    // Are we using an extension-based Save button or context menu?
    pinMeOnly = $.d.querySelectorAll("[data-pin-me-only]");
    // if we find exactly one, it's our hoverbutton or context menu image.
    if (
    // is there exactly one?
    pinMeOnly.length === 1) {
      // process this link only
      processImage(pinMeOnly[0]);
    } else {
      // override.og may have been set by a page-level discovery
      if ($.v.override.og) {
        debug("og overridden");
      } else {
        // be nice to people who share via Open Graph, even though it's kind of a dumpster fire
        if ($.v.data.meta.og) {
          mod = {};
          debug("og found");
          if ($.v.data.meta.og.image) {
            // do we have a string value?
            if (typeof $.v.data.meta.og.image === "string") {
              debug("og:image found");
              mod.ogMedia = $.v.data.meta.og.image;
            } else {
              // do we have an array?
              if ($.v.data.meta.og.image[0]) {
                debug("og:image array found; using the first element");
                q = $.v.data.meta.og.image[0];
              } else {
                q = $.v.data.meta.og.image;
              }
              // do we have a strng
              if (typeof q === "string") {
                debug("og:image found in object");
                mod.ogMedia = q;
              } else {
                // do we have a secure URL?
                if (q.secure_url && typeof q.secure_url === "string") {
                  debug("og:secure_url found");
                  mod.ogMedia = q.secure_url;
                } else {
                  // has the original value of image been saved as a string in the ~ member because it has children such as height or width?
                  if (q["~"] && typeof q["~"] === "string") {
                    debug("og:~ found");
                    mod.ogMedia = q["~"];
                  }
                }
              }
            }
            // do we have an URL?
            if ($.v.data.meta.og.url) {
              if (typeof $.v.data.meta.og.url === "string") {
                mod.ogUrl = $.v.data.meta.og.url;
              } else {
                debug("More than one og:url found");
                mod.ogUrl = $.v.data.meta.og.url[0];
              }
              debug("og:url found");
            }
            if ($.v.data.meta.og.site_name) {
              if (typeof $.v.data.meta.og.site_name === "string") {
                $.v.ogSiteName = $.v.data.meta.og.site_name;
              } else {
                debug("More than one og:site_name found");
                $.v.ogSiteName = $.v.data.meta.og.site_name[0];
              }
            }
            if ($.v.data.meta.og.description || $.v.data.meta.og.title) {
              debug("og:title or og:description found");
              mod.ogDescription = $.v.data.meta.og.description || $.v.data.meta.og.title;
              if (typeof mod.ogDescription === "string") {
                $.v.ogDescription = mod.ogDescription;
              } else {
                debug("More than one og:description found");
                $.v.ogDescription = mod.ogDescription[0];
              }
            }
            debug("loading og:image");
            // load the image we placed in mod.ogMedia, not anything we found in $.v.data.meta.og.image, which could be an array
            loadImg({ src: mod.ogMedia, mod: mod });
          }
        }
      }

      m = $.d.getElementsByTagName("IMG");

      for (i = 0; i < m.length; i = i + 1) {
        processImage(m[i]);
      }
    }
  }

  // handle link exceptions

  function handleLink() {
    var m = void 0,
        i = void 0;
    m = $.d.getElementsByTagName("LINK");
    for (i = 0; i < m.length; i = i + 1) {
      // knowing the canonical link will help us identify products on some pages
      if (m[i].rel && m[i].rel.toLowerCase() === "canonical" && m[i].href) {
        $.v.data.link.canonical = m[i].href;
        $.v.data.url = m[i].href;
        break;
      }
    }
  }

  // watch for data-pin-title

  function handleMeta() {
    var _patch = void 0,
        mod = {},
        arr = [],
        obj = {},
        meta = document.getElementsByTagName("META"),
        key = void 0,
        value = void 0,
        i = void 0,
        j = void 0,
        k = void 0,
        q = void 0,
        z = void 0;

    // scrape our META tags, looking for keys and values
    for (i = 0; i < meta.length; i = i + 1) {
      value = meta[i].getAttribute("content");
      if (value) {
        // get the property or name
        key = meta[i].getAttribute("property") || meta[i].getAttribute("name");
        if (key) {
          // instantly short-circuit if we find the nopin meta
          if (key.toLowerCase() === "pinterest" && value.toLowerCase() === "nopin") {
            return meta[i].getAttribute("description") || true;
          }
          // ignore any metas with data-pin-nopin
          if (!meta[i].getAttribute("data-pin-nopin")) {
            // push into an array so we can sort it later
            arr.push({ k: key, v: value });
          }
        }
      }
    }

    // sort our array so we don't wind up overwriting things as we split on colons
    arr.sort(function (a, b) {
      var r = 0;
      if (a.k > b.k) {
        r = 1;
      } else {
        if (a.k < b.k) {
          r = -1;
        }
      }
      return r;
    });

    // our array now contains objects with keys and values, sorted by key
    for (i = 0; i < arr.length; i = i + 1) {
      // split each key on the colon
      k = arr[i].k.split(":");
      // start at the root of the object we're working on
      z = obj;
      for (j = 0; j < k.length; j = j + 1) {
        if (typeof z[k[j]] === "undefined") {
          // make a new sub-object
          z[k[j]] = {};
        }
        // go again
        z = z[k[j]];
      }
      // see if we've seen this one before
      q = _typeof(z["~"]);
      if (q === "undefined") {
        // key does not exist, so add it
        z["~"] = arr[i].v;
      } else {
        // turn existing duplicate strings into arrays
        if (q === "string") {
          // convert the existing string into the first element of an array
          z["~"] = [z["~"]];
        }
        // push the next value onto the array
        z["~"].push(arr[i].v);
      }
    }
    // recursively fix up the naive object so strings show as strings
    // but objects that have both strings and sub-objects aren't lost
    _patch = function patch(obj, parentObj, parentKey) {
      for (var _k in obj) {
        if (_typeof(obj[_k]) === "object") {
          // is this member zero of an array?
          if (typeof obj[_k][0] === "string") {
            parentObj[parentKey] = obj[_k];
          } else {
            _patch(obj[_k], obj, _k);
          }
        } else {
          // if we have only one key, it's the ~, so we can set object[key] equal to its string value
          if (Object.keys(obj).length === 1) {
            parentObj[parentKey] = obj[_k];
          }

          // YOLO ALERT: this will deliver misleading results for situations like this:
          //
          //   <meta name="foo" content="woo">
          //   <meta name="foo" content="yay">
          //   <meta name="foo:bar" content="baz">
          //
          // ... where we will get:
          //
          //     foo:["woo","yay"]
          //
          // ... instead of:
          //
          //     foo:{"~":["woo", "yay"],"bar":"baz"}
          //
          // As of right now this is good enough for what we need
        }
      }
      return obj;
    };

    $.v.data.meta = _patch(obj, null, null);

    // we have not found the Pinterest nopin meta, so look for special meta spaces (OG and Pinterest)
    mod = {};
    debug("meta data found");
    debug($.v.data.meta);

    // look for Pinterest metas
    if ($.v.data.meta.pin) {
      debug("data-pin found");

      if ($.v.data.meta.pin.url) {
        debug("data-pin-url found");
        mod.pinUrl = $.v.data.meta.pin.url;
        // always override canonical link if we find data-pin-url
        $.v.override.link = true;
      }

      if ($.v.data.meta.pin.description) {
        debug("data-pin-description found");
        mod.pinDescription = $.v.data.meta.pin.description;
      }

      if ($.v.data.meta.pin.title) {
        debug("data-pin-title found");
        mod.pinTitle = $.v.data.meta.pin.title;
      }

      if ($.v.data.meta.pin.id) {
        debug("data-pin-id found");
        mod.pinId = $.v.data.meta.pin.id;
        // don't show the imageless pin if we have a pin ID
        $.v.override.imageless = true;
      }

      // don't require pin:media in order for title or description to work
      // we will need these for rich front end whether or not there's media
      if ($.v.data.meta.pin.media) {
        debug("data-pin-media found");
        mod.pinMedia = $.v.data.meta.pin.media;
        debug("loading data-pin-media");
        loadImg({ src: $.v.data.meta.pin.media, mod: mod });
      }
    }

    // seek and report Instagram owner, media ID, and hashtags
    // Instagram username will be deduced from linked data
    if ($.v.data.meta.instapp) {
      if ($.v.data.meta.instapp.owner_user_id) {
        if ($.v.data.meta.al) {
          if ($.v.data.meta.al.ios) {
            if ($.v.data.meta.al.ios.url && $.v.data.meta.al.ios.url.match("=")) {
              $.v.insta = {
                owner: $.v.data.meta.instapp.owner_user_id,
                id: $.v.data.meta.al.ios.url.split("=")[1]
              };
              if ($.v.data.meta.instapp.hashtags) {
                // toString works on numbers, strings, and arrays
                $.v.insta.hashtags = $.v.data.meta.instapp.hashtags.toString();
              }
            }
          }
        }
      }
    }

    // look for Open Graph values
    if ($.v.data.meta.og) {
      // patch for image.secure_url
      if (_typeof($.v.data.meta.og.image) === "object") {
        $.v.data.meta.og.image = $.v.data.meta.og.image.secure_url || undefined;
      }
      // fix cases where we've found more than one title, description, url, or image
      k = ["description", "title", "url", "image"];
      for (i = 0; i < k.length; i = i + 1) {
        if ($.v.data.meta.og[k[i]]) {
          if (typeof $.v.data.meta.og[k[i]] !== "string") {
            $.v.data.meta.og[k[i]] = $.v.data.meta.og[k[i]][0];
          }
        }
      }
    }
  }

  // parse linked data inside SCRIPT tags

  function handleScript() {
    var script = document.getElementsByTagName("SCRIPT"),
        i = void 0,
        n = void 0;

    // scrape our SCRIPT tags
    for (i = 0, n = script.length; i < n; i = i + 1) {
      // do we have a type?
      if (script[i].type) {
        // does the type indidate linked data?
        if (script[i].type === "application/ld+json") {
          // does the script contain text content?
          if (script[i].innerText) {
            try {
              // stack it on our predefined array of linked data objects
              $.v.data.script.push(JSON.parse(script[i].innerText));
            } catch (parseError) {
              debug("Could not parse linked data.");
              debug(script[i].innerText);
            }
          }
        }
      }
    }
  }

  // handle iframe exceptions

  function handlePage() {
    var k = void 0,
        r = void 0,
        p = void 0,
        q = void 0,
        u = void 0;

    var results = void 0,
        thumb = void 0,
        a = void 0,
        i = void 0,
        j = void 0,
        url = void 0,
        media = void 0,
        img = void 0,
        pinMeOnly = void 0;

    r = false;

    // Amazon page on mobile
    if (!r && $.v.here.match($.a.pattern.page.amazonPage)) {
      // grab all images
      k = $.d.getElementsByTagName("IMG");
      for (q = 0; q < k.length; q = q + 1) {
        // seek the ASIN attribute, currently data-fling-asin
        u = k[q].getAttribute($.a.pattern.att.amazonAsin);
        // if we found it and it's in document.URL, we're done
        if (u && $.v.here.match(u)) {
          loadImg({
            src: k[q].currentSrc,
            // if we successfully load this image, don't offer the imageless pin
            override: ["imageless"],
            mod: {
              // hand-whittle the product URL in case we're on a GP page, which has no canonical URL
              url: "https://www.amazon.com/dp/" + u + "/",
              description: getDescription(k[q])
            }
          });
          r = true;
          break;
        }
      }
    }

    // desktop Amazon product page
    if (!r && $.v.here.match($.a.pattern.page.amazonProduct)) {
      k = $.d.getElementById("imgTagWrapperId");
      if (k) {
        p = k.getElementsByTagName("IMG")[0];
        if (p) {
          loadImg({
            src: p.src,
            // if we successfully load this image, don't offer the imageless pin
            override: ["imageless"],
            mod: {
              url: $.v.data.link.canonical,
              description: getDescription(p)
            }
          });
          r = true;
        }
      }
    }

    // be nice to Instagram
    // WARNING: this is brittle, has broken in the past, and is guaranteed to break again
    if (!r && $.v.here.match($.a.pattern.page.instagramPage)) {
      debug("On an Instagram property");

      // some Instagram pages (search results, explore) have no og:title
      var instaTitle = $.d.title;

      if ($.v.data.meta.og && $.v.data.meta.og.title) {
        // some people are putting colons in their titles so we need
        // to split on the full `Instagram: “` string
        // watch out: that's a curly quote
        instaTitle = $.v.data.meta.og.title.split("Instagram: “");
        if (instaTitle[1]) {
          instaTitle = instaTitle[1]
          // drop the last quote
          .substring(0, instaTitle[1].length - 1)
          // trim whitespace
          .trim();
        } else {
          // default to document.title
          instaTitle = $.d.title;
        }
      }

      if ($.v.here.match($.a.pattern.page.instagramPhoto)) {
        debug("On an Instagram photo URL");

        // find the first image tag inside an element and load it
        // along with its ALT or OG:TITLE
        var getSrc = function getSrc(el) {
          q = el.getElementsByTagName("IMG");
          if (q.length) {
            for (k = 0; k < q.length; k = k + 1) {
              loadImg({
                src: q[k].currentSrc,
                override: ["imageless"],
                mod: {
                  url: $.v.here.split("?")[0],
                  // as of 2018-11-28 we are seeing "no automatic text available" on most Instagram alt attributes, so we're going to ignore it
                  description: instaTitle
                }
              });
              // only set r to true when we know we have at least one good image
              r = true;
              // 2018-11-26: don't break out of this loop
              // otherwise we wind up with Instagram avatars instead of photos
            }
          }
        };

        // Are we in the main carousel?
        var instaArticle = $.d.getElementsByTagName("ARTICLE");
        if (instaArticle.length === 2) {
          debug("in main carousel");
          getSrc(instaArticle[1]);
          if (r) {
            debug("Found image in carousel.");
          } else {
            debug("Found carousel but no image.");
          }
        }
        // Are we on a canonical page?
        if (!r) {
          var instaButton = $.d.querySelectorAll("[role=button]");
          if (instaButton.length) {
            getSrc(instaButton[1]);
            if (r) {
              debug("Found image in button.");
            } else {
              debug("Found button but no image.");
            }
          }
        }
      } else {
        debug("On a non-photo Instagram page");
        // this could be anything; a profile, search results, story, tag explore page
        k = $.d.getElementsByTagName("IMG");
        for (u = 0; u < k.length; u = u + 1) {
          // save what's currently on the screen
          if (k[u].currentSrc) {
            // if we're in a link, use that for the pin
            q = k[u].parentNode.parentNode.parentNode;
            if (q.tagName === "A" && q.href && q.href.match(/^https?:\/\//)) {
              // we've found the parent link
              loadImg({
                src: k[u].currentSrc,
                // if we successfully load this image, don't offer the imageless pin
                override: ["imageless"],
                mod: {
                  url: q.href.split("?")[0],
                  // as of 2018-11-28 we are seeing "no automatic text available" on most Instagram alt attributes, so we're going to ignore it
                  // yes, we are kinda screwed here
                  description: instaTitle
                }
              });
            }
          }
        }
      }
    }

    // YouTube video page
    if (!r && $.v.here.match($.a.pattern.page.youtubeWatch)) {
      p = $.v.here.split("v=")[1].split("&")[0].split("#")[0];
      if (p) {
        debug("found a YouTube page: " + $.v.here);
        loadImg({
          src: "https://img.youtube.com/vi/" + p + "/hqdefault.jpg",
          // if we successfully load this image, don't offer the imageless pin
          override: ["imageless"],
          mod: {
            description: $.d.title,
            multimedia: true,
            url: "https://www.youtube.com/watch?v=" + p
          }
        });
        r = true;
      }
    }

    // YouTube mobile page
    // if r is true, we've already found a watch page
    if (!r && $.v.here.match($.a.pattern.page.youtubeMobile)) {
      k = $.d.getElementsByTagName("A");
      for (u = 0; u < k.length; u = u + 1) {
        if (k[u].href && k[u].href.match($.a.pattern.link.youtubeWatch)) {
          p = k[u].href.split("v=")[1].split("&")[0].split("#")[0];
          if (p) {
            debug("found a YouTube video: " + k[u].href);
            loadImg({
              src: "https://img.youtube.com/vi/" + p + "/hqdefault.jpg",
              // if we successfully load this image, don't offer the imageless pin
              override: ["imageless"],
              mod: {
                description: $.d.title,
                multimedia: true,
                url: "https://www.youtube.com/watch?v=" + p
              }
            });
            r = true;
          }
        }
      }
    }

    // Google Image Search results: find proper links; allow data:URIs
    if (!r && $.v.here.match($.a.pattern.page.googleImageSearch)) {
      // when Google changes this ID this whole thing will break
      // symptoms: we are pinning tiny images that link back to Google Image Search,
      // and their discriptions all say "dog - Google Search"
      results = $.d.getElementById("isr_mc");
      // did we find the content display area?
      if (results) {
        // we're only going to show the images we get from this special process
        $.v.override.img = true;
        // never show the imageless pin
        $.v.override.imageless = true;
        // process a Google Image Search link to get proper image source, URL, and description
        var processGoogleImageSearchLink = function processGoogleImageSearchLink(link) {
          url = "";
          media = "";
          // find the page link
          p = link.href.split("imgrefurl=");
          if (p[1]) {
            try {
              url = decodeURIComponent(p[1].split("&")[0]);
            } catch (e) {
              debug("Could not run decodeURIComponent on " + p[1]);
            }
          }
          // find the media link
          p = link.href.split("imgurl=");
          if (p[1]) {
            try {
              media = decodeURIComponent(p[1].split("&")[0]);
            } catch (e) {
              debug("Could not run decodeURIComponent on " + p[1]);
            }
          }
          // build a thumb if we have url and media links
          if (url && media) {
            thumb = {
              src: media,
              mod: {
                url: url
              }
            };
            // attempt to find a description
            // sadly this will not work for the top 20 images, which will all fall
            // back to something like "dog - Google Search"
            p = link.parentNode.getElementsByTagName("DIV");
            if (p[2] && p[2].textContent) {
              try {
                j = JSON.parse(p[2].textContent);
                if ((typeof j === "undefined" ? "undefined" : _typeof(j)) === "object") {
                  if (j.s || j.pt) {
                    thumb.mod.description = j.s || j.pt;
                  }
                }
              } catch (e) {
                thumb.mod.description = p[2].textContent;
                debug("Could not run JSON.parse on " + p[2].textContent);
              }
            }
            // we have a thumb; kick off the image loader
            loadImg(thumb);
            // let the calling function know we found something on this page
            r = true;
          }
        };
        // Are we using an extension-based Save button or context menu?
        pinMeOnly = $.d.querySelectorAll("[data-pin-me-only]");
        // if we find exactly one and it has a containing link, it's our hoverbutton or context menu image.
        if (
        // is there exactly one?
        pinMeOnly.length === 1 &&
        // does it have a parentNode?
        pinMeOnly[0].parentNode &&
        // is the parent node a link?
        pinMeOnly[0].parentNode.tagName === "A") {
          // process this link only
          processGoogleImageSearchLink(pinMeOnly[0].parentNode);
        } else {
          // we are running pinmarklet, process all the links
          a = results.getElementsByTagName("A");
          for (i = 0; i < a.length; i = i + 1) {
            if (a[i].href) {
              // are there any images inside this link?
              img = a[i].getElementsByTagName("IMG");
              if (img[0] && img[0].src) {
                // does the first image inside this link have a source?
                processGoogleImageSearchLink(a[i]);
              }
            }
          }
        }
      }
    }
    // return false if we found nothing, true if we found at least one thing
    return r;
  }

  // what to do if we're running inside our Android app

  function extend_android() {
    // look for Android callback
    if ($.w.JavaScriptInterface && $.w.JavaScriptInterface.onPinsLoaded) {
      $.v.config.render = "openAndroidAppShare";
      $.w.openAndroidAppShare = function () {
        $.w.JavaScriptInterface.onPinsLoaded(JSON.stringify($.v.data));
      };
      // fire this if $.v.data.close alerts anything
      $.f.extendedClose = function () {
        $.w.JavaScriptInterface.onPinsLoaded(JSON.stringify({ pinmarkletClosedReason: $.v.data.close }));
      };
      debug("Android app found");
      $.v.extended = true;
    }
  }

  // what to do if we're running inside one of our browser extensions

  function extend_browser() {
    var b = void 0,
        v = void 0,
        i = void 0,
        p = void 0;
    if (typeof chrome !== "undefined") {
      b = chrome;
    } else {
      if (typeof browser !== "undefined") {
        b = browser;
      }
    }
    if (b && b.runtime && b.runtime.getManifest && b.runtime.sendMessage) {
      v = b.runtime.getManifest().version;
      p = v.split(".");
      for (i = 0; i < p.length; i = i + 1) {
        p[i] = p[i] - 0;
      }
      // are we on a v2 extension?
      if (p[0] > 1) {
        // this will be overwritten later by getConfig for other clients
        $.v.config.render = "openGrid";
        $.w.openGrid = function () {
          $.v.data.config = $.v.config;
          $.v.data.config.k = $.a.k;
          // remove unused callback; prevent console spew in Chrome 72
          b.runtime.sendMessage({
            to: "background",
            act: "populateGrid",
            data: $.v.data
          });
        };
        // fire this if $.v.data.close alerts anything
        $.f.extendedClose = function () {
          // remove unused callback; prevent console spew in Chrome 72
          b.runtime.sendMessage({ to: "background", act: "closeGrid" });
        };
        debug("advanced browser extension found");
        // only do extended behaviors for v2 extensions
        $.v.extended = true;
        // don't try to run json-p calls from inside browser extensions
        $.v.doNotCall = true;
      }
    }
  }

  // what to do if we're running inside our IOS app

  function extend_ios() {
    // look for IOS callback
    if ($.w.webkit && $.w.webkit.messageHandlers && $.w.webkit.messageHandlers.pinmarkletCompletionHandler && $.w.webkit.messageHandlers.pinmarkletCompletionHandler.postMessage) {
      $.v.config.render = "openIOSAppShare";
      $.w.openIOSAppShare = function () {
        $.w.webkit.messageHandlers.pinmarkletCompletionHandler.postMessage($.v.data);
      };
      $.v.config.quiet = true;
      // fire this if $.v.data.close alerts anything
      $.f.extendedClose = function () {
        $.w.webkit.messageHandlers.pinmarkletCompletionHandler.postMessage({
          pinmarkletClosedReason: $.v.data.close
        });
      };
      debug("IOS app found");
      $.v.extended = true;
    }
  }

  // make an imageless pin representation

  function makeImageless() {
    var domain = void 0,
        hsvToRgb = void 0;
    // we will pick a background color based on domain
    domain = $.v.here.split("/")[2];
    // convert HSV color to RGB triple
    hsvToRgb = function hsvToRgb(h, s, v) {
      var i = void 0,
          f = void 0,
          p = void 0,
          q = void 0,
          t = void 0,
          r = void 0,
          g = void 0,
          b = void 0,
          format = void 0;
      h = h / 60;
      i = Math.floor(h);
      f = h - i;
      p = v * (1 - s);
      q = v * (1 - s * f);
      t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        case 5:
          r = v;
          g = p;
          b = q;
          break;
        default:
      }
      // convert to two-digit hex value
      format = function format(n) {
        return ("00" + Math.round(n * 255).toString(16)).substr(-2, 2);
      };
      // format for use on a Web page
      return "#" + format(r) + format(g) + format(b);
    };
    // build and return
    return {
      description: getDescription({ imageless: true }),
      height: $.a.thumbSize,
      width: $.a.thumbSize,
      score: $.a.thumbSize * $.a.thumbSize,
      url: $.v.here,
      siteName: $.v.ogSiteName || domain,
      color: hsvToRgb(parseInt(sha({ str: domain }).substr(0, 3), 16) % 360, 0.25, 0.75)
    };
  }

  // pop the unauthed grid (default behavior if we are not sending data to an extendedClose function

  function grid() {
    var k = void 0,
        rule = void 0,
        closeGrid = void 0,
        startTime = void 0,
        renderTime = void 0;

    // get the page's current overflow style; we're going to set it to hidden to freeze background scrolling
    $.v.defaultBodyOverflow = "";
    // don't leave "visible" as an inline style; it's the default
    if ($.v.defaultBodyOverflow === "visible") {
      $.v.defaultBodyOverflow = "";
    }
    // freeze the page underneath the modal
    $.d.body.style.overflow = "hidden";
    debug("popping the unauthed grid");
    $.v.data.config = $.v.config;
    $.v.data.hazExtension = get($.d.body, "data-pinterest-extension-installed");
    k = JSON.stringify($.v.data);
    $.s.grid = $.d.createElement("IFRAME");
    $.s.grid.id = $.a.k + "_grid";
    $.s.grid.src = $.a.grid;
    $.s.grid.frameBorder = "0";

    // style the iframe
    for (rule in $.a.iframeStyle) {
      if ($.a.iframeStyle[rule].hasOwnProperty) {
        $.s.grid.style[rule] = $.a.iframeStyle[rule];
      }
    }

    // when we're done
    closeGrid = function closeGrid() {
      $.d.body.style.overflow = $.v.defaultBodyOverflow;
      $.d.body.removeAttribute($.a.hazPinningNow);
      if ($.s.grid && $.s.grid.parentNode && $.s.grid.parentNode === $.d.body) {
        $.d.body.removeChild($.s.grid);
      }
    };
    startTime = new Date().getTime();
    $.s.grid.onload = function () {
      renderTime = new Date().getTime() - startTime;
      debug("Grid render time: " + renderTime);
      log({ reason: "grid_rendered", time: renderTime });
      $.v.receiver = $.s.grid.contentWindow;
      $.v.receiver.postMessage(k, $.s.grid.src);
      $.w.addEventListener("message", function (e) {
        $.w.clearTimeout($.v.renderFailed);
        if (e.data === "x") {
          closeGrid();
        }
      });
      $.s.grid.focus();
    };
    $.d.body.setAttribute($.a.hazPinningNow, true);
    $.d.body.appendChild($.s.grid);
    // iframe has five seconds to reply with "rendered" or we kill it
    $.v.renderFailed = $.w.setTimeout(function () {
      log({ reason: "iframe_timeout" });
      closeGrid();
      $.v.data.close = $.v.config.msg.noPinnablesFound;
      done();
    }, $.a.maxWait);
  }

  // render found data

  function render() {
    debug($.v.data);
    log({
      reason: "scan_complete",
      time: new Date().getTime() - $.v.time.start,
      url: $.d.URL
    });
    // do we need to close instead of pinning
    if ($.v.data.close) {
      done();
    } else {
      // are we using the IOS share extension?
      if ($.v.config.share) {
        debug("sending results to IOS share extension");
        $.d.body.setAttribute($.v.config.share, JSON.stringify($.v.data));
      } else {
        // are we using an extension or mobile app?
        if (typeof $.w[$.v.config.render] === "function") {
          debug("sending results to " + $.v.config.render);
          $.w[$.v.config.render]($.v.data);
        } else {
          // default to the iframed grid overlay
          debug("sending results to our default iframe grid overlay");
          grid();
        }
      }
    }
  }

  // if all we found is an imageless pin, log it

  function process() {
    var i = void 0,
        n = void 0,
        k = void 0,
        ch = void 0,
        cw = void 0,
        mf = void 0,
        item = void 0,
        arr = [],
        imageless = void 0,
        ig = void 0;
    for (k in $.v.data.img) {
      if ($.v.data.img[k].hasOwnProperty) {
        item = $.v.data.img[k];
        if (item.status === "ok") {
          item.url = $.v.data.url;
          if (!item.mod) {
            item.mod = {};
          }
          // we have successfully loaded and measured this image
          mf = 1;
          ch = item.height;
          cw = item.width;
          if (cw > ch) {
            // trim width on landscape images
            cw = ch;
          } else {
            // trim height on giraffe images
            if (ch > cw * 3) {
              ch = cw * 3;
            }
          }
          // have we changed the description?
          if (item.mod.description) {
            item.description = item.mod.description;
          }
          // check again for ogDescription
          if (item.mod.ogDescription) {
            item.description = item.mod.ogDescription;
          }
          // has the site operator specified a different description?
          if (item.mod.pinDescription) {
            item.description = item.mod.pinDescription;
          }
          // never pass a description with more than 500 characters
          if (item.description && item.description.length > 500) {
            item.description = item.description.substring(0, 500);
          }
          // have we changed the URL?
          if (item.mod.url) {
            item.url = item.mod.url;
          }
          // has the site operator specified a different URL?
          if (item.mod.pinUrl) {
            item.url = item.mod.pinUrl;
          }
          // media has already been loaded into the src attribute and checked for things like pinMedia
          item.media = item.src;
          // fix up multiplication factor
          if (item.mod.multimedia) {
            mf = mf * 3;
          }
          // bump if the operator has suggested an alternate URL or image
          if (item.mod.pinUrl || item.mod.pinMedia) {
            mf = mf * 4;
          }
          // only pin this image
          if (item.mod.pinMeOnly) {
            mf = mf * 1000000;
          }
          // do we have a pin ID?
          if (item.mod.pinId) {
            mf = mf * 10;
            // save this id so we know to repin from the grid
            item.dataPinId = item.mod.pinId;
            // extensions and mobile apps expect data.id
            item.id = item.mod.pinId;
            // don't show the imageless pin if we have a pin ID
            $.v.override.imageless = true;
          }
          // small images go to the bottom
          if (item.width < $.a.thumbSize) {
            mf = mf / 2;
          }
          if (item.mod.multimedia) {
            // don't show the imageless pin if we have a video
            $.v.override.imageless = true;
            mf = mf * 2;
          }
          // a slight adjustment for source order, so identically-sized images show in the order they appear
          item.score = ch * cw * mf - (item.mod.sourceOrder || 0);
          arr.push(item);
        }
      }
    }
    // add the imageless pin representation
    if (!$.v.override.imageless) {
      imageless = makeImageless();
      $.v.data.imageless = imageless;
      arr.push(imageless);
      // if all we found is an imageless pin, log it
      if (arr.length === 1) {
        log({ reason: "imageless_only" });
      }
    }
    // sort by score, in descending order
    arr.sort(function (a, b) {
      var v = 0;
      if (a.score < b.score) {
        v = 1;
      } else {
        if (a.score > b.score) {
          v = -1;
        }
      }
      return v;
    });

    // filter any array items whose score is less than the top score divided by 10
    arr = arr.filter(function (i) {
      // only return if our score is better than the best score divided by our quality minimum
      return i.score > arr[0].score / $.a.quality;
    });

    $.v.data.thumb = arr;

    var addRichData = function addRichData(key, value) {
      // if we don't have a rich data object yet, make one
      if (!$.v.data.rich) {
        $.v.data.rich = {};
      }
      // don't overwrite existing values
      if (!$.v.data.rich[key]) {
        debug("Adding rich data: " + key + " " + value);
        $.v.data.rich[key] = value;
      } else {
        debug("Ignoring duplicate rich data: " + key + " " + value);
      }
    };

    if ($.v.data.meta) {
      // check Pinterest METAs first
      if ($.v.data.meta.pin) {
        if ($.v.data.meta.pin.title) {
          addRichData("title", $.v.data.meta.pin.title);
        }
        if ($.v.data.meta.pin.description) {
          addRichData("description", $.v.data.meta.pin.description);
        }
        if ($.v.data.meta.pin.url) {
          addRichData("url", $.v.data.meta.pin.url);
        }
      }
      // check Open Graph METAs next
      // if we have already found a title, description, or URL, addRichData won't overwrite
      if ($.v.data.meta.og) {
        if ($.v.data.meta.og.title) {
          addRichData("title", $.v.data.meta.og.title);
        }
        if ($.v.data.meta.og.description) {
          addRichData("description", $.v.data.meta.og.description);
        }
        if ($.v.data.meta.og.url) {
          addRichData("url", $.v.data.meta.og.url);
        }
      }

      // check META name=description
      // if we have already found a description, addRichData won't overwrite
      if ($.v.data.meta.description && typeof $.v.data.meta.description === "string") {
        addRichData("description", $.v.data.meta.description);
      }
    }

    // check document.title
    // if we have already found a title, addRichData won't overwrite
    if (document.title && typeof document.title === "string") {
      addRichData("title", document.title);
    }

    // if we have a canonical link, report it as the rich link
    // if we have already found an URL, addRichData won't overwrite
    if ($.v.data.link) {
      if ($.v.data.link.canonical) {
        addRichData("url", $.v.data.link.canonical);
      }
    }

    // got Instagram?
    if ($.v.insta) {
      // did we find any scripts with linked data?
      for (i = 0, n = $.v.data.script.length; i < n; i = i + 1) {
        // did we find the author's @-name?
        if ($.v.data.script[i].author && $.v.data.script[i].author.alternateName) {
          // save it as usename
          $.v.insta.username = $.v.data.script[i].author.alternateName;
        }
      }
      // add me to rich data so clients can save
      $.v.data.rich.instagram = $.v.insta;
      // get ready to do a flat request back to log.pinterest.com
      ig = {
        reason: "insta_found",
        extras: {
          media_id: $.v.insta.id,
          owner_id: $.v.insta.owner,
          username: $.v.insta.username
        }
      };
      if ($.v.insta.hashtags) {
        ig.extras.hashtags = $.v.insta.hashtags;
      }
      // log me
      log(ig);
    }

    render();
  }

  // choose the right set of strings, using window.navigator.language as a clue

  function strings(o) {
    var i = void 0,
        t = void 0,
        lang = void 0,
        locale = void 0;
    t = $.w.navigator.language.toLowerCase();
    t = t.replace(/[^a-z0-9]/g, " ");
    t = t.replace(/^\s+|\s+$/g, "");
    t = t.replace(/\s+/g, " ");
    t = t.split(" ");
    // fix three-parters like bs-latn-ba
    if (t.length > 2) {
      for (i = t.length - 1; i > -1; i = i - 1) {
        if (t[i].length !== 2) {
          t.splice(i, 1);
        }
      }
    }
    lang = t[0];
    if (t[1]) {
      locale = t[0] + "-" + t[1];
    }
    // is there an immediate match for language in strings?
    if ($.a.msg[locale]) {
      $.v.config.lang = locale;
    } else {
      if ($.a.msg[lang]) {
        $.v.config.lang = lang;
      }
    }
    $.v.config.msg = $.a.msg[$.v.config.lang];
  }

  // /u/kill is not currently used in pinmarklet; leaving it for later use in extension code as we convert other monolithic blocks

  function kill(o) {
    if (typeof o === "string") {
      o = $.d.getElementById(o);
    }
    if (o && o.parentNode) {
      o.parentNode.removeChild(o);
    }
  }

  // get configuration options from the SCRIPT tag matching $.a.me

  function config$1(o) {
    var i = void 0,
        j = void 0,
        v = void 0,
        s = $.d.getElementsByTagName("SCRIPT");
    // loop through all SCRIPT tags backwards, so we look at the last one first
    for (i = s.length - 1; i > -1; i = i - 1) {
      // are we on one whose source matches ours?
      if (s[i].src.match($.a.me)) {
        // loop through all possible valid config parameters
        for (j = 0; j < $.a.config.length; j = j + 1) {
          v = get({ el: s[i], att: $.a.config[j] });
          if (v) {
            $.v.config[$.a.config[j]] = v;
          }
        }
        // kill the SCRIPT tag
        kill(s[i]);
        // stop looking for more
        break;
      }
    }
  }

  // housekeeping

  function init() {
    var msg = void 0,
        _checkDone = void 0;
    debug("My key: " + $.a.k);
    // don't run if we're already running
    if (!$.d.body.getAttribute($.a.hazPinningNow)) {
      // do not run on any version of IE below 11
      if ($.w.navigator.userAgent.match(" MSIE ")) {
        // log that we're on an unsupported version of IE
        log({ reason: "oldIE" });
      } else {
        // see if any config flags were passed
        config$1();
        // if a "here" value has been pased in config, use it instead of document.URL
        if ($.v.config.here) {
          $.v.here = $.v.config.here;
        } else {
          $.v.here = $.d.URL;
        }
        // don't log pmInit until after we know $.v.here
        log({ reason: "init" });
        // get our strings
        strings();
        // injected by IOS share extension
        if (typeof DATA_RESULTS_KEY === "string") {
          $.v.config.share = DATA_RESULTS_KEY;
        }
        // add behaviors for known extensions and apps
        if (!$.v.extended) {
          extend_android();
          extend_browser();
          extend_ios();
        }
        if (checkDisallowedDomain({ url: $.v.here })) {
          // log that we're on an unpinnable domain
          log({ reason: "domain_not_allowed" });
          $.v.data.close = $.v.config.msg.noPinDomain;
          // done will decide whether to pop an alert or not
          done();
        } else {
          // check for linked data
          handleScript();
          // short-curcuit if we find meta name=pinterest content=nopin directive
          msg = handleMeta();
          if (msg) {
            // log that we're on an unpinnable domain
            log({ reason: "found_nopin_meta" });
            if (msg === true) {
              $.v.data.close = $.v.config.msg.noPinMeta;
            } else {
              $.v.data.close = msg;
            }
            done();
          } else {
            // successfully gotten past old IE, disallowed domain, and nopin meta tests
            debug("Initing");
            // structure space for inline grid
            $.s = {};
            // default the URL we're pinning to document.URL
            $.v.data.url = $.v.here;
            // page handler will return true if we find a canonical thing-to-pin
            if (!handlePage()) {
              // handle embedded pages and players
              handleIframe();
              // handle embedded images, unless we've said not to
              if (!$.v.override.img) {
                handleImg();
              }
              // check for canonical link before running page handler
              if (!$.v.override.link) {
                handleLink();
              }
            }
            // all handlers may have added images to loading stack. Here we try to wait until done
            _checkDone = function checkDone() {
              if (!$.v.count.imgLoading && !$.v.count.apiCalls) {
                process();
              } else {
                debug("images left to load: " + $.v.count.imgLoading);
                debug("api calls outstanding: " + $.v.count.apiCalls);
                if (new Date().getTime() < $.v.time.start + $.a.maxWait) {
                  $.w.setTimeout(_checkDone, 10);
                } else {
                  debug("Timed out, rendering what we have.");
                  process();
                }
              }
            };
            $.w.setTimeout(_checkDone, 100);
          }
        }
      }
    }
  }

  init();

}());
